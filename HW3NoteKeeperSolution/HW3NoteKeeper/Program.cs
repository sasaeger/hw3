// Importing necessary namespaces for OpenAPI (Swagger), reflection, custom settings, database initialization, exception handling, JSON serialization, custom exceptions, Azure Identity for secure access, Azure Blob storage interaction, repository pattern implementation, and Entity Framework Core.
using Microsoft.OpenApi.Models;
using System.Reflection;
using HW3NoteKeeper.CustomSettings;
using static HW3NoteKeeper.Data.DBInitializer;
using Microsoft.AspNetCore.Diagnostics;
using System.Text.Json;
using ExceptionHandling.DataTransferObjects;
using EntityNotFoundException = HW3NoteKeeper.Exceptions.EntityNotFoundException;
using HW3NoteKeeper.Exceptions;
using HW3NoteKeeper.Data;
using Azure.Identity;
using Azure.Storage.Blobs;
using AzureBlobManagedIdentity.Repositories;
using Microsoft.EntityFrameworkCore;

// Start of the web application builder pattern, configuring services and middleware for the app.
var builder = WebApplication.CreateBuilder(args);

// Adds MVC controllers to the application's services.
builder.Services.AddControllers();

// Enables API metadata generation which is used by Swagger.
builder.Services.AddEndpointsApiExplorer();

// Configures Swagger to generate API documentation.
builder.Services.AddSwaggerGen(c =>
{
    // Retrieves the XML file generated by the build process that contains the XML comments.
    var xmlFile = $"{Assembly.GetExecutingAssembly().GetName().Name}.xml";
    var xmlPath = Path.Combine(AppContext.BaseDirectory, xmlFile);
    // Tells Swagger to include the XML comments in the generated JSON.
    c.IncludeXmlComments(xmlPath);

    // Configures Swagger document details such as title, version, and description.
    c.SwaggerDoc("v2", new OpenApiInfo
    {
        Title = "Note Keeper",
        Version = "v2",
        Description = "Scott Saeger's Note Keeping API",
        Contact = new OpenApiContact
        {
            Name = "Scott Saeger",
            Email = "scs307@g.harvard.edu",
        },
    });
});

// Configures Entity Framework Core with SQL Server as the database provider using the connection string from the application settings.
string ConnectionString = builder.Configuration.GetConnectionString("DefaultConnection");
builder.Services.AddDbContext<MyDatabaseContext>(options => options.UseSqlServer(ConnectionString));

// Instantiates settings classes and binds them to the corresponding sections in the app settings.
NoteLimits noteLimits = new();
AttachmentLimits attachmentLimits = new();
builder.Configuration.GetSection(nameof(NoteLimits)).Bind(noteLimits);
builder.Configuration.GetSection(nameof(AttachmentLimits)).Bind(attachmentLimits);

// Registers the settings instances as singletons in the application's service container.
builder.Services.AddSingleton(noteLimits);
builder.Services.AddSingleton(attachmentLimits);

// Configures Azure Identity default credentials for authenticating to Azure services securely.
var credential = new DefaultAzureCredential(new DefaultAzureCredentialOptions
{
    SharedTokenCacheTenantId = builder.Configuration.GetValue<string>("StorageAccountSettings:TenantId"),
    VisualStudioCodeTenantId = builder.Configuration.GetValue<string>("StorageAccountSettings:TenantId"),
    VisualStudioTenantId = builder.Configuration.GetValue<string>("StorageAccountSettings:TenantId")
});

// Registers BlobServiceClient as a singleton to interact with Azure Blob Storage, using the configured credentials and endpoint from the app settings.
builder.Services.AddSingleton(new BlobServiceClient(new Uri(builder.Configuration.GetValue<string>("StorageAccountSettings:BlobServiceEndpoint")), credential));

// Registers the StorageRepository class as a scoped service, ensuring a new instance is created for each HTTP request but shared across the request's scope.
builder.Services.AddScoped<StorageRepository>();

// Completes the application configuration and creates an instance of the application.
var app = builder.Build();

// Configures the HTTP request pipeline, including exception handling, Swagger, HTTPS redirection, and authorization.
if (app.Environment.IsDevelopment())
{
    app.UseSwagger();
    app.UseSwaggerUI(c => c.SwaggerEndpoint("/swagger/v2/swagger.json", "Note Keeper API V2"));
}

// Configures a global exception handler to catch and format exceptions into a standardized JSON structure.
app.UseExceptionHandler(MapExceptionToPublicErrorResponse);

// Redirects HTTP requests to HTTPS, enhancing security.
app.UseHttpsRedirection();

// Activates authorization capabilities, preparing for securing endpoints.
app.UseAuthorization();

// Maps controller routes, enabling the routing of HTTP requests to controller actions.
app.MapControllers();

// Starts the web application, listening for incoming HTTP requests.
app.Run();

// Defines a method for mapping exceptions to standardized JSON error responses, improving API usability and error handling.
static void MapExceptionToPublicErrorResponse(IApplicationBuilder builder)
{
    builder.Run(async context =>
    {
        // Retrieves the exception from the current HTTP context.
        var ex = context.Features.Get<IExceptionHandlerFeature>()?.Error;
        
        // Initializes a new instance of the PublicErrorResponse class.
        var errorResponse = new PublicErrorResponse();

        // Distinguishes between different types of exceptions to provide more specific error information.
        if (ex is ArgumentException ae)
        {
            // Sets the HTTP response status code for bad requests.
            context.Response.StatusCode = StatusCodes.Status400BadRequest;
            
            // Populates the error response with relevant details.
            errorResponse.Number = ErrorNumberConstants.BadParameterError;
            errorResponse.Description = $"Invalid Parameter: {ae.ParamName}. {ae.Message}";
        }
        else if (ex is EntityNotFoundException enf)
        {
            // Sets the HTTP response status code for not found errors.
            context.Response.StatusCode = StatusCodes.Status404NotFound;
            
            // Populates the error response with relevant details.
            errorResponse.Number = ErrorNumberConstants.EntityNotFoundError;
            errorResponse.Description = $"Entity Not Found: {enf.Id}. {enf.Message}";
        }
        else
        {
            // Sets the HTTP response status code for internal server errors.
            context.Response.StatusCode = StatusCodes.Status500InternalServerError;
        
            // Populates the error response with relevant details.
            errorResponse.Number = ErrorNumberConstants.InternalError;
            errorResponse.Description = "An internal server error occurred.";
        }

        // Sets the HTTP response content type to JSON.
        context.Response.ContentType = "application/json";
        
        // Serializes the error response to a JSON string with indentation for readability.
        var jsonResult = JsonSerializer.Serialize(errorResponse, new JsonSerializerOptions { WriteIndented = true });
        
        // Writes the serialized JSON error response to the HTTP response body.
        await context.Response.WriteAsync(jsonResult);
    });
}
